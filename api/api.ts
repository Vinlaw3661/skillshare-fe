/* tslint:disable */
/* eslint-disable */
/**
 * SkillShare Local API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
  replaceWithSerializableTypeIfNeeded,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

export interface CreateRatingRequest {
  session_id: string;
  rating: number;
  comment?: string | null;
}
export interface CreateRatingResponse {
  id: string;
  session_id: string;
  session_title: string;
  session_date: string;
  host_id: string;
  host_name: string;
  reviewer_id: string;
  reviewer_name: string;
  rating: number;
  comment?: string | null;
  created_at: string;
}
export interface EnrollmentResponse {
  id: string;
  session_id: string;
  session_title: string;
  session_start_time: string;
  session_end_time: string;
  session_location: string;
  host_id: string;
  host_name: string;
  user_id: string;
  user_name: string;
  enrolled_at: string;
  status: string;
}
export interface HTTPValidationError {
  detail?: Array<ValidationError>;
}
export interface LocationInner {}
export interface LoginRequest {
  username_or_email: string;
  password: string;
}
export interface SessionCreateRequest {
  /**
   * Session title
   */
  title: string;
  /**
   * Session description
   */
  description: string;
  /**
   * Skill category
   */
  skill_category: string;
  /**
   * Session location
   */
  location: string;
  start_time: string;
  end_time: string;
  capacity: number;
  price: number;
}
export interface SessionCreateResponse {
  id: string;
  title: string;
  description: string;
  skill_category: string;
  location: string;
  start_time: string;
  end_time: string;
  capacity: number;
  price: number;
  host_id: string;
  enrolled_count: number;
  status: string;
  created_at: string;
}
export interface SessionEnrolleesResponse {
  session_id: string;
  session_title: string;
  capacity: number;
  enrolled_count: number;
  available_spots: number;
  enrollees: Array<any>;
}
export interface SessionRatingsResponse {
  session_id: string;
  session_title: string;
  average_rating: number;
  total_ratings: number;
  ratings: Array<CreateRatingResponse>;
}
export interface SessionUpdateRequest {
  title?: string | null;
  description?: string | null;
  skill_category?: string | null;
  location?: string | null;
  start_time?: string | null;
  end_time?: string | null;
  capacity?: number | null;
  price?: number | null;
}
export interface Token {
  access_token: string;
  token_type: string;
}
export interface UserCreateRequest {
  first_name: string;
  last_name: string;
  username: string;
  email: string;
  password: string;
  bio?: string | null;
}
export interface UserCreateResponse {
  id: string;
  first_name: string;
  last_name: string;
  username: string;
  email: string;
  bio?: string | null;
  date_joined: string;
}
export interface UserEnrollmentsSummary {
  user_id: string;
  user_name: string;
  upcoming_sessions: number;
  past_sessions: number;
  cancelled_sessions: number;
  total_sessions: number;
}
export interface UserUpdateRequest {
  first_name?: string | null;
  last_name?: string | null;
  bio?: string | null;
}
export interface ValidationError {
  loc: Array<LocationInner>;
  msg: string;
  type: string;
}

/**
 * EnrollmentsApi - axios parameter creator
 */
export const EnrollmentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * - Must be enrolled in the session - Cannot cancel after session has started
     * @summary Cancel Enrollment
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete",
        "sessionId",
        sessionId,
      );
      const localVarPath = `/enrollments/sessions/{session_id}/enroll`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check if current user is enrolled in a session Useful for frontend to show \"Enroll\" vs \"Cancel Enrollment\" button
     * @summary Check Enrollment Status
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet",
        "sessionId",
        sessionId,
      );
      const localVarPath =
        `/enrollments/sessions/{session_id}/check-enrollment`.replace(
          `{${"session_id"}}`,
          encodeURIComponent(String(sessionId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Session must exist and be active Session must not be at capacity User cannot enroll in their own session User cannot enroll twice in same session Session must not have already started
     * @summary Enroll In Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enrollInSessionEnrollmentsSessionsSessionIdEnrollPost: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "enrollInSessionEnrollmentsSessionsSessionIdEnrollPost",
        "sessionId",
        sessionId,
      );
      const localVarPath = `/enrollments/sessions/{session_id}/enroll`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * status_filter: \"enrolled\", \"cancelled\", \"completed\", \"all\" (default: \"enrolled\")
     * @summary Get My Enrollments
     * @param {string} [statusFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyEnrollmentsEnrollmentsMyEnrollmentsGet: async (
      statusFilter?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/enrollments/my-enrollments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (statusFilter !== undefined) {
        localVarQueryParameter["status_filter"] = statusFilter;
      }

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get summary of current user\'s enrollments
     * @summary Get My Enrollments Summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/enrollments/my-enrollments/summary`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of users enrolled in a session (PUBLIC)
     * @summary Get Session Enrollees
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet",
        "sessionId",
        sessionId,
      );
      const localVarPath =
        `/enrollments/sessions/{session_id}/enrollees`.replace(
          `{${"session_id"}}`,
          encodeURIComponent(String(sessionId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnrollmentsApi - functional programming interface
 */
export const EnrollmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EnrollmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * - Must be enrolled in the session - Cannot cancel after session has started
     * @summary Cancel Enrollment
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
          sessionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check if current user is enrolled in a session Useful for frontend to show \"Enroll\" vs \"Cancel Enrollment\" button
     * @summary Check Enrollment Status
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
          sessionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Session must exist and be active Session must not be at capacity User cannot enroll in their own session User cannot enroll twice in same session Session must not have already started
     * @summary Enroll In Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EnrollmentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(
          sessionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.enrollInSessionEnrollmentsSessionsSessionIdEnrollPost"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * status_filter: \"enrolled\", \"cancelled\", \"completed\", \"all\" (default: \"enrolled\")
     * @summary Get My Enrollments
     * @param {string} [statusFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyEnrollmentsEnrollmentsMyEnrollmentsGet(
      statusFilter?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<EnrollmentResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMyEnrollmentsEnrollmentsMyEnrollmentsGet(
          statusFilter,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.getMyEnrollmentsEnrollmentsMyEnrollmentsGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get summary of current user\'s enrollments
     * @summary Get My Enrollments Summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserEnrollmentsSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get list of users enrolled in a session (PUBLIC)
     * @summary Get Session Enrollees
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SessionEnrolleesResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
          sessionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EnrollmentsApi.getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * EnrollmentsApi - factory interface
 */
export const EnrollmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EnrollmentsApiFp(configuration);
  return {
    /**
     * - Must be enrolled in the session - Cannot cancel after session has started
     * @summary Cancel Enrollment
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
          sessionId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Check if current user is enrolled in a session Useful for frontend to show \"Enroll\" vs \"Cancel Enrollment\" button
     * @summary Check Enrollment Status
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<any> {
      return localVarFp
        .checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
          sessionId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Session must exist and be active Session must not be at capacity User cannot enroll in their own session User cannot enroll twice in same session Session must not have already started
     * @summary Enroll In Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<EnrollmentResponse> {
      return localVarFp
        .enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(
          sessionId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * status_filter: \"enrolled\", \"cancelled\", \"completed\", \"all\" (default: \"enrolled\")
     * @summary Get My Enrollments
     * @param {string} [statusFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyEnrollmentsEnrollmentsMyEnrollmentsGet(
      statusFilter?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<EnrollmentResponse>> {
      return localVarFp
        .getMyEnrollmentsEnrollmentsMyEnrollmentsGet(statusFilter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get summary of current user\'s enrollments
     * @summary Get My Enrollments Summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserEnrollmentsSummary> {
      return localVarFp
        .getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get list of users enrolled in a session (PUBLIC)
     * @summary Get Session Enrollees
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionEnrolleesResponse> {
      return localVarFp
        .getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
          sessionId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EnrollmentsApi - object-oriented interface
 */
export class EnrollmentsApi extends BaseAPI {
  /**
   * - Must be enrolled in the session - Cannot cancel after session has started
   * @summary Cancel Enrollment
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
    sessionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .cancelEnrollmentEnrollmentsSessionsSessionIdEnrollDelete(
        sessionId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check if current user is enrolled in a session Useful for frontend to show \"Enroll\" vs \"Cancel Enrollment\" button
   * @summary Check Enrollment Status
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
    sessionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .checkEnrollmentStatusEnrollmentsSessionsSessionIdCheckEnrollmentGet(
        sessionId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Session must exist and be active Session must not be at capacity User cannot enroll in their own session User cannot enroll twice in same session Session must not have already started
   * @summary Enroll In Session
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(
    sessionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .enrollInSessionEnrollmentsSessionsSessionIdEnrollPost(sessionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * status_filter: \"enrolled\", \"cancelled\", \"completed\", \"all\" (default: \"enrolled\")
   * @summary Get My Enrollments
   * @param {string} [statusFilter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getMyEnrollmentsEnrollmentsMyEnrollmentsGet(
    statusFilter?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .getMyEnrollmentsEnrollmentsMyEnrollmentsGet(statusFilter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get summary of current user\'s enrollments
   * @summary Get My Enrollments Summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .getMyEnrollmentsSummaryEnrollmentsMyEnrollmentsSummaryGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of users enrolled in a session (PUBLIC)
   * @summary Get Session Enrollees
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
    sessionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return EnrollmentsApiFp(this.configuration)
      .getSessionEnrolleesEnrollmentsSessionsSessionIdEnrolleesGet(
        sessionId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RatingsApi - axios parameter creator
 */
export const RatingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Rating
     * @param {CreateRatingRequest} createRatingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRatingRatingsCreateRatingPost: async (
      createRatingRequest: CreateRatingRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createRatingRequest' is not null or undefined
      assertParamExists(
        "createRatingRatingsCreateRatingPost",
        "createRatingRequest",
        createRatingRequest,
      );
      const localVarPath = `/ratings/create-rating`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createRatingRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Ratings For Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatingsForSessionRatingsSessionSessionIdRatingsGet: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists(
        "getRatingsForSessionRatingsSessionSessionIdRatingsGet",
        "sessionId",
        sessionId,
      );
      const localVarPath = `/ratings/session/{session_id}/ratings`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RatingsApi - functional programming interface
 */
export const RatingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RatingsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Rating
     * @param {CreateRatingRequest} createRatingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRatingRatingsCreateRatingPost(
      createRatingRequest: CreateRatingRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateRatingResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createRatingRatingsCreateRatingPost(
          createRatingRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RatingsApi.createRatingRatingsCreateRatingPost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Ratings For Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRatingsForSessionRatingsSessionSessionIdRatingsGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SessionRatingsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRatingsForSessionRatingsSessionSessionIdRatingsGet(
          sessionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "RatingsApi.getRatingsForSessionRatingsSessionSessionIdRatingsGet"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RatingsApi - factory interface
 */
export const RatingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RatingsApiFp(configuration);
  return {
    /**
     *
     * @summary Create Rating
     * @param {CreateRatingRequest} createRatingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRatingRatingsCreateRatingPost(
      createRatingRequest: CreateRatingRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateRatingResponse> {
      return localVarFp
        .createRatingRatingsCreateRatingPost(createRatingRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Ratings For Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatingsForSessionRatingsSessionSessionIdRatingsGet(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionRatingsResponse> {
      return localVarFp
        .getRatingsForSessionRatingsSessionSessionIdRatingsGet(
          sessionId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RatingsApi - object-oriented interface
 */
export class RatingsApi extends BaseAPI {
  /**
   *
   * @summary Create Rating
   * @param {CreateRatingRequest} createRatingRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createRatingRatingsCreateRatingPost(
    createRatingRequest: CreateRatingRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return RatingsApiFp(this.configuration)
      .createRatingRatingsCreateRatingPost(createRatingRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Ratings For Session
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getRatingsForSessionRatingsSessionSessionIdRatingsGet(
    sessionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RatingsApiFp(this.configuration)
      .getRatingsForSessionRatingsSessionSessionIdRatingsGet(sessionId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SessionsApi - axios parameter creator
 */
export const SessionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Session
     * @param {SessionCreateRequest} sessionCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession: async (
      sessionCreateRequest: SessionCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionCreateRequest' is not null or undefined
      assertParamExists(
        "createSession",
        "sessionCreateRequest",
        sessionCreateRequest,
      );
      const localVarPath = `/sessions/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sessionCreateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("deleteSession", "sessionId", sessionId);
      const localVarPath = `/sessions/{session_id}`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (
      sessionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("getSession", "sessionId", sessionId);
      const localVarPath = `/sessions/{session_id}`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sessions/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Session
     * @param {string} sessionId
     * @param {SessionUpdateRequest} sessionUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSession: async (
      sessionId: string,
      sessionUpdateRequest: SessionUpdateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sessionId' is not null or undefined
      assertParamExists("updateSession", "sessionId", sessionId);
      // verify required parameter 'sessionUpdateRequest' is not null or undefined
      assertParamExists(
        "updateSession",
        "sessionUpdateRequest",
        sessionUpdateRequest,
      );
      const localVarPath = `/sessions/{session_id}`.replace(
        `{${"session_id"}}`,
        encodeURIComponent(String(sessionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sessionUpdateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SessionsApi - functional programming interface
 */
export const SessionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Session
     * @param {SessionCreateRequest} sessionCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSession(
      sessionCreateRequest: SessionCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SessionCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(
        sessionCreateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SessionsApi.createSession"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSession(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(
        sessionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SessionsApi.deleteSession"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SessionCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(
        sessionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SessionsApi.getSession"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSessions(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SessionCreateResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listSessions(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SessionsApi.listSessions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Session
     * @param {string} sessionId
     * @param {SessionUpdateRequest} sessionUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSession(
      sessionId: string,
      sessionUpdateRequest: SessionUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SessionCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSession(
        sessionId,
        sessionUpdateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SessionsApi.updateSession"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SessionsApi - factory interface
 */
export const SessionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SessionsApiFp(configuration);
  return {
    /**
     *
     * @summary Create Session
     * @param {SessionCreateRequest} sessionCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSession(
      sessionCreateRequest: SessionCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionCreateResponse> {
      return localVarFp
        .createSession(sessionCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSession(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSession(sessionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Session
     * @param {string} sessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(
      sessionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionCreateResponse> {
      return localVarFp
        .getSession(sessionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSessions(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<SessionCreateResponse>> {
      return localVarFp
        .listSessions(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Session
     * @param {string} sessionId
     * @param {SessionUpdateRequest} sessionUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSession(
      sessionId: string,
      sessionUpdateRequest: SessionUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SessionCreateResponse> {
      return localVarFp
        .updateSession(sessionId, sessionUpdateRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SessionsApi - object-oriented interface
 */
export class SessionsApi extends BaseAPI {
  /**
   *
   * @summary Create Session
   * @param {SessionCreateRequest} sessionCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createSession(
    sessionCreateRequest: SessionCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SessionsApiFp(this.configuration)
      .createSession(sessionCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Session
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteSession(sessionId: string, options?: RawAxiosRequestConfig) {
    return SessionsApiFp(this.configuration)
      .deleteSession(sessionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Session
   * @param {string} sessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getSession(sessionId: string, options?: RawAxiosRequestConfig) {
    return SessionsApiFp(this.configuration)
      .getSession(sessionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List Sessions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listSessions(options?: RawAxiosRequestConfig) {
    return SessionsApiFp(this.configuration)
      .listSessions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Session
   * @param {string} sessionId
   * @param {SessionUpdateRequest} sessionUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateSession(
    sessionId: string,
    sessionUpdateRequest: SessionUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SessionsApiFp(this.configuration)
      .updateSession(sessionId, sessionUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (
      userId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserById", "userId", userId);
      const localVarPath = `/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: async (
      loginRequest: LoginRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists("loginUser", "loginRequest", loginRequest);
      const localVarPath = `/users/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register User
     * @param {UserCreateRequest} userCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      userCreateRequest: UserCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreateRequest' is not null or undefined
      assertParamExists("registerUser", "userCreateRequest", userCreateRequest);
      const localVarPath = `/users/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Current User
     * @param {UserUpdateRequest} userUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userUpdateRequest: UserUpdateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userUpdateRequest' is not null or undefined
      assertParamExists("updateUser", "userUpdateRequest", userUpdateRequest);
      const localVarPath = `/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";
      localVarHeaderParameter["Accept"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserCreateResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUser(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUser"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUser(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(
        loginRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.loginUser"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Register User
     * @param {UserCreateRequest} userCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      userCreateRequest: UserCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        userCreateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.registerUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Current User
     * @param {UserUpdateRequest} userUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userUpdateRequest: UserUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserCreateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userUpdateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.updateUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserCreateResponse> {
      return localVarFp
        .getUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserCreateResponse> {
      return localVarFp
        .getUserById(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Token> {
      return localVarFp
        .loginUser(loginRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Register User
     * @param {UserCreateRequest} userCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      userCreateRequest: UserCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserCreateResponse> {
      return localVarFp
        .registerUser(userCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Current User
     * @param {UserUpdateRequest} userUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userUpdateRequest: UserUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserCreateResponse> {
      return localVarFp
        .updateUser(userUpdateRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Get Current User Info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getUser(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get User
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getUserById(userId: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserById(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login
   * @param {LoginRequest} loginRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public loginUser(
    loginRequest: LoginRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .loginUser(loginRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Register User
   * @param {UserCreateRequest} userCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public registerUser(
    userCreateRequest: UserCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .registerUser(userCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Current User
   * @param {UserUpdateRequest} userUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateUser(
    userUpdateRequest: UserUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(userUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
